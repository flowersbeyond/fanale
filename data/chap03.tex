\chapter{搜索引擎优化}
\label{cha:filter}
\newcommand{\SmartDebug}{
	\textbf{\textit{SmartDebug}}
}

\section{引言}%2
介绍搜索引擎在“生成-检验”系统中的功能、作用，基本设计思想、技术路线和存在问题。
\section{相关工作}%4
重点介绍GenProg，Par，SPR，SemFix，DirectFix，Prophet，NOPOL等较完整的系统。
\section{“预过滤”优化技术}%6
介绍“预过滤”的基本思想，详细介绍具体算法，讨论其理论上的优势与实际应用中的局限性。
\section{实验结果及分析}%7
“预过滤”策略对搜索空间的压缩作用：将其与SPR、NOPOL的压缩效果进行比较分析。
\section{本章小结}%1

\section{Introduction}
Debugging has long been recognized as one of the most time- and labour- costing activity in software engineering practice. To accelerate debugging process, recently a series of ``generate-and-validate" systems are proposed to generate fix suggestions to programmers so that a buggy program can pass a certain test suite.
However, two major drawbacks prevents existing systems from practical usage. First, most systems generate program mutations that include only one location of changes in the program. As a result, bugs that require fixes at multi-location, which widely exists in real coding practice, can never be fixed. Second, reported experimental results show that the fix generation time can be too long that programmers may take less time fixing the bug manually.

In this paper, we propose \SmartDebug, an interactive Java debug assistant that implements a generate-and-validate system while aiming to overcome these two drawbacks. More than existing systems, it utilizes programmers' judgment of program running state by taking in ``Checkpoints", a user-interface we provide for recording programmers' expectations of program running at arbitrary execution positions, so that complicated debug tasks can be split into small fragment of tasks that are solvable separately yet automatically. Therefore \SmartDebug is able to work with bugs that require modifications on several locations to be fixed. \SmartDebug presented in this paper is an upgraded system of our previous work \cite{Guo:2016:SID:2950290.2983971}. It implements our newly proposed optimization strategy called ``early filtration", which filter out mutations that are impossible to fix the program before they enter into the validation phase, so that the search space is dramatically reduced and generation process correspondingly accelerated.

\SmartDebug is implemented as an Eclipse plug-in integrated with the JDT debugger. For evaluation, we first run \SmartDebug against Defects4J to inspect the effectiveness of ``early filtration". Experimental results show that \SmartDebug is able to fix 24 versions, the largest amount ever reported on this benchmark. With early filtration, the mutations that enter into validation phase reduced to less than 10\% on 12 versions, and 20\% on 8 more versions. To prove that \SmartDebug is able to actually speed up the debugging process, we also evaluate the plug-in on 25 real bugs that appeared during the development process of programing exam. Results show that \SmartDebug is able to accelerate the debugging process on 7 bugs.

Structure of the paper is organized as follows. Background and related work are discussed in Section II. In Section III we explain the design and the two features of \SmartDebug. Implementation details are presented in Section IV while evaluation results are reported in Section V. Finally Section VI concludes the paper.



\section{Background and Related Work}
``Generate-and-validate" systems are proposed as a solution to automatic general bug fixing. They generate possible fixes on the source code that makes the program under test pass a certain test suite. As the name suggests, they first generate a series of program mutations as fix candidates, then apply them to the program , and finally rerun the tests for validation. Major differences between existing systems reside in the ``generate" process, and we cluster them as follows.

\textbf{GenProg, RSRepair, AE and Kali:}
GenProg\cite{6035728}\cite{6227211} performs genetic search to generate fixes that are composed of code ingredients from the software system itself. RSRepair\cite{Qi:2014:SRS:2568225.2568254} adopts a random search algorithm instead. AE\cite{6693094} deterministically searches for patches and utilizes program equivalence to prune the search space. However analysis in \cite{qi2015analysis} show that most of the patches generated by these systems actually removes program features rather than corrects bugs. To prove this analysis, Kali\cite{qi2015analysis} is designed as a function remover and the experiments show that Kali works just as well. Therefore it remains a question whether these systems can actually work on real software bugs.

\textbf{Par:}In \cite{kim2013automatic}, the authors summarized 9 common fix patterns by analyzing fix patterns in open-source software repositories, and used them as templates to generate fixes. The authors claim that the patches generated by Par are more acceptable by developers than GenProg.

\textbf{Angelic Debugging, NOPOL, SemFix and DirectFix:} Angelic debugging\cite{chandra2011angelic} replaces expressions with an angelic variable-a variable that takes an arbitrary value-and see if the program can successfully pass the tests. NOPOL\cite{demarco2014automatic} narrows the target expression in \cite{chandra2011angelic} to condition expressions in Java. If such expression exists, a replacement expression is synthesized with an SMT solver. SemFix\cite{nguyen2013semfix} uses symbolic execution to calculate the constraints that an replacement expression must satisfy for a potential buggy expression. It then uses an SMT-solver to synthesize such expression. DirectFix\cite{mechtaev2015directfix} improves SemFix as it fuses the fault localization and repair generation into one step by utilizing MaxSAT constraint solving and program synthesis to generate the simplest expression modifications.

\textbf{SPR and Prophet:} SPR, short for staged program repair\cite{Long:2015:SPR:2786805.2786811}, first generates possible sequences of the value of a target condition expression such that the failed test may take a correct execution route, then synthesizes such condition expression. \cite{long2016automatic} sorts the prioritizes fixes by their probability of being the correct fix.

\SmartDebug differs from existing systems as it allows user annotation and specification of program execution, so that multi-site fixes are handled naturally. Also, the ``early-filtration" technique is proposed and applied exclusively by us to sharply reduce the candidate fixes going into the validation process and speeds up the process dramatically. Most importantly, \SmartDebug is a usable demo integrated in a widely used IDE, which can indeed improve debug efficiency for programmers.
\begin{table*}[!t]
	\centering
	\caption{Search Space Specification}
	\label{search-space}
	\begin{tabular}{|l|l|}
		\hline
		Fix Pattern                & Explanations                                                                                                                                      \\ \hline
		expression fix     & change an expression to a type-compatible
		expression                                                                                              \\ \hline
		branch introduction        & insert if(...) return/break/continue;                                                                                \\ \hline
		branch expression fix      & modify if-conditions as general expression fix and change expression ``e" to ``!e", ``e || e' ", ``e \&\& e'" 
		\\ \hline
		array boundary checks      & insert if(i \textgreater= 0 \&\& i \textless= array.length)\{ array access statement; \}                                                          \\ \hline
		collection boundary checks & insert if (i \textgreater= 0 \&\& i \textless= list.size())\{collection.get(i) statement;\}                                                       \\ \hline
		null pointer checks        & insert if(obj != null)\{ object access statement;\}                                                                                                  \\ \hline
		cast type checks           & insert if(obj instanceof Type)\{Supertype obj1 = (Type)obj;\}                                                                                          \\ \hline
		method overload            & change a.b(c1, c2, ..., cn) to a.b'(c1, c2, ..., cn)                                                                                              \\ \hline
		method override            & change a.b(c1,c2,..., cn) to a.b(c1, c2, ..., cm)                                                                                                 \\ \hline
	\end{tabular}
	\vspace{-1.8em}
\end{table*}

\section{Tool Design}

Figure 1 shows the system architecture of \SmartDebug. \SmartDebug consists two major components, the \textit{Interactive Frontend} and the \textit{Fix Generation Backend}. The Interactive Frontend provides facilities for programmers to describe their judgments and expectations of the program running state through ``Checkpoints" (\textit{Checkpoint Manager}). It also tracks the debugging process of the program, i.e. the satisfaction status of each Checkpoint on each test case, guiding the programmer through the whole debugging task (\textit{Debug Process Controller}). The \textit{Fix Generation Backend} first localizes the bug by collecting and analyzing the execution trace of each test case (the \textit{Fault Localizer)}, then generates program mutations within a predefined \textit{Search Space} according to the generated ranking list of suspicious fix sites (\textit{Search Engine}), after which some of the mutations go through a \textit{Filter} that removes mutations impossible to fix the bug. Finally the survived mutations are validated by applying them back to the program and rerun the test suite (\textit{Final Validator}).

Search space specification is vital in fix correctness rate in generate-and-validate systems. \SmartDebug adopts the mutation patterns listed in Table I, whose first column lists the name of patterns and the second column provides brief explanations.

\SmartDebug distinguishes itself from peer systems by two major features. One is the interactive debugging usage model, which requires a collaboration among several components mentioned above. Second is the early-filtration strategy, implemented in \textit{Filter}. 

\subsection{Interactive Debugging}

The interactive debugging usage model aims to take advantage of programmers' understanding of the program under test to break down complicated bugs into simple fractions and narrow down possible bug locations to improve the debug efficiency.

From the programmers' perspective, \SmartDebug works as a personal consultant. During the common debugging process using JDT debug frontend, the programmer is able to describe his judgment of the program running state at a certain point of execution to \SmartDebug through \textit{Checkpoints}. If the program executes correctly, the programmer can mark down this execution point as ``correct". Otherwise, he or she can input a boolean expression that should evaluate to \texttt{true} if the program runs correctly as a description of his or her expectations.

\SmartDebug tracks the current debugging process. Figure 2 shows a snapshot of the debug process control panel. The panel lists every checkpoint and their current satisfaction status. For each failing test case, \SmartDebug will find the first failing checkpoint it encounters during execution. The programmer may choose any failing checkpoints as the debug target in the next step.

When searching for fixes, the fault localizer utilizes the information of checkpoint to achieve more accurate fault localization. We adopt the Ochiai\cite{Abreu:2006:ESC:1193217.1194368} fault localization metric, however the execution trace of the test case containing the target checkpoint is divided into two segments by the last correct checkpoint. The first segment is counted as a successful execution trace, while the second failing. Only code lines covered by the second segment will be treated as possible fix positions. Therefore \SmartDebug is able to focus on a possibly small fraction of programs.

In the validation process, we do not rigorously require the candidate fixes to pass all test cases, instead we report every fix that can fix the target checkpoint while we rank the fixes according to the number of test cases the program passes if they are applied.




\subsection{Early Filtration}

The huge search space has always been an obstacle in developing efficient generate-and-validate systems. ``Early filtration", by the name, means to filter impossible fix candidates early in the generate phase, so that they do not flow to the validate phase, which leads to a dramatic compression of the search space and improves efficiency sharply. Unlike SPR\cite{Long:2015:SPR:2786805.2786811}, ``early filtration" works on fixes that modifies expressions, or that contains modifications of expressions, thus are not limited to only condition expression.

``Early filtration" is proposed based on the observation that if an expression A is to be replaced with an expression B, then:
\begin{itemize}	
	\item{In order to ensure that all the passed tests remain passed, B should be ``equal" to A at each time the program runs to the position where A is evaluated.}
	\item{In order to correct the failed tests, B should NOT be ``equal" to A in at least one time when A is evaluated.}
\end{itemize}

For fix pattern 1, this observation can be applied directly. For fix patterns 2-6, the modified or newly introduced branch condition should be seen as expression A in the above observation.

Note that the criteria of ``equality" is critical in applying this observation. Equality between primitive values is straight forward. For non-primitive objects, equality is defined as the equality of all primitive-typed fields of the object.

We are currently working on Java programs. JVM makes it very convenient to ``halt" the execution process at a certain point and evaluate the value of an expression on a hot stack, which is in orders of magnitude faster than a complete ``rebuild-and-rerun" procedure. Therefore, through early filtration, we can save a large amount of time since mass majority of the candidates can be filtered out before entering to the validation process.
\section{Evaluation}

\subsection{Effectiveness of Early Filtration}
We propose ``early filtration" strategy to improve the search efficiency of ``generate-and-validate" systems. To evaluate its effectiveness, we tested \SmartDebug against the Defects4J\cite{Just:2014:DDE:2610384.2628055}
benchmark, a collection of several hundred versions of 5 real world programs. We compared the number of fixes that needed to be validated in the final validator with or without ``early filtration".

\SmartDebug succeeded in fixing 24 bugs in Defects4J, the largest number currently reported on this benchmark. Table II presents the number of program mutations generated before and survived after filtration. Column ``EXPR" records the number of expression related mutations where early filtration is applicable. ``METHOD" denotes the number of method overriding and overloading mutations where early filtration is not applicable. Column ``VAL" reports the number of mutations that need to be validated by the final validator, which includes the survived expression related mutations and also method related mutations. The last column computes the reduction rate. Results show that in 12 versions only 10\% mutations needs to be validated while in 8 more versions only 20\%. The reduction is especially remarkable when large number of mutations are generated as in closure compiler version 1, 10, 118, 125, 92 and 93.

\begin{table}[!t]
	\centering
	\caption{Early Filtration Effectiveness on Defects4J}
	\label{defects4j}
	\begin{tabular}{|l|l|l|l|l|}
		\hline
		Version\_ID            & EXPR  & METH & VAL & RED   \\ \hline
		closure\_compiler\_1   & 154963 & 624 & 1878     & 1.21\%   \\ \hline
		closure\_compiler\_10  & 249694 & 2783 & 3596     & 1.42\%   \\ \hline
		closure\_compiler\_118 & 298024 & 1311 & 1635     & 0.55\%   \\ \hline
		closure\_compiler\_125 & 212912 & 417 & 530      & 0.25\%   \\ \hline
		closure\_compiler\_51  & 1812   & 54   & 58       & 3.11\%   \\ \hline
		closure\_compiler\_62  & 61     & 1     & 4        & 6.45\%   \\ \hline
		closure\_compiler\_63  & 327    & 77    & 80       & 19.80\%  \\ \hline
		closure\_compiler\_73  & 1052   & 7   & 11       & 1.04\%   \\ \hline
		closure\_compiler\_86  & 869    & 160   & 177      & 17.20\%  \\ \hline
		closure\_compiler\_92  & 17300  & 279  & 1550     & 8.82\%   \\ \hline
		closure\_compiler\_93  & 17475  & 279  & 1538     & 8.66\%   \\ \hline
		commons\_lang3\_24     & 950    & 6    & 124      & 12.97\%  \\ \hline
		commons\_lang3\_26     & 313    & 43    & 58       & 16.29\%  \\ \hline
		commons\_lang3\_6      & 375    & 57    & 122      & 28.24\%  \\ \hline
		commons\_math\_75      & 1      & 35     & 36       & 100.00\% \\ \hline
		commons\_math\_80      & 1033   & 100   & 391      & 34.51\%  \\ \hline
		commons\_math\_82      & 704    & 80    & 95       & 12.12\%  \\ \hline
		commons\_math\_85      & 230    & 39    & 42       & 15.61\%  \\ \hline
		commons\_math3\_33     & 1527   & 56   & 69       & 4.36\%   \\ \hline
		commons\_math3\_5      & 58     & 0     & 8        & 13.79\%  \\ \hline
		jfreechart\_1          & 7632   & 193   & 1134     & 14.49\%  \\ \hline
		jfreechart\_11         & 256    & 8    & 9        & 3.41\%   \\ \hline
		jfreechart\_24         & 54     & 26     & 40       & 50.00\%  \\ \hline
		jfreechart\_9          & 61     & 3     & 4        & 6.25\%   \\ \hline
	\end{tabular}
	\vspace{-0.7em}
\end{table}

\subsection{Interactive Debugging Efficiency}
We collected 25 versions of buggy programs from a coding exam for first year graduate students and asked students in the same year to debug these programs with or without help of \SmartDebug. We recorded the time cost on both situations and compared them in Table III.


\begin{table}[!b]
	\label{tab:sd-vs-human}
	\centering
	\caption{SmartDebug v.s. Human}
	\vspace{-0.8em}
	\begin{tabular}{|c|l|c|c|} \hline
		No.& Bug Summary 									& SD(s) & H(s)	\\	\hline
		1  & wrong usage of loop variables					& 282	& 300	\\	\hline
		2  & wrong operator									& 95	& 691	\\	\hline
		3  & wrong usage of a local variable				& 1055	& 694	\\  \hline
		4  & wrong usage of loop variables					& 260	& 423	\\	\hline
		5  & wrong usage of loop variables					& 309	& 410	\\	\hline
		6  & wrong usage of loop variables					& 198	& 341 	\\	\hline
		7 & wrong usage of a numeric variable				& 215	& 829	\\	\hline
		8 & wrong usage of a local variable				& 228	& 600	\\	\hline
		
	\end{tabular}
\end{table}

Experiments show that without human interference, \SmartDebug is able to generate correct fix suggestions for 8 of the buggy versions in acceptable time. On 7 versions of programs \SmartDebug accelerated the manual debugging process. Generally with help of \SmartDebug the debug task is finished within 5 minutes.

\section{Conclusion}
In this paper, we present \SmartDebug, an interactive debug assistant for Java. \SmartDebug distinguishes from existing ``generate-and-validate" systems in two major features, the interactive usage paradigm and early-filtration optimization strategy. Experiments show that through early-filtration, program mutations are dramatically reduced when entering the validation phase, thus accelerating the fix generation process prominently. Through the interactive usage model, \SmartDebug is capable of supporting multi-location fixes that cover wider practical usage scenarios. Experimental results show that \SmartDebug is able to facilitate the manual debugging process.